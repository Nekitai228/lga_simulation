#include <stdio.h>
#include <math.h>
#include <stdlib.h> //srand()
#include <time.h>

#define MAX_N 64 //Максимальный размер поля
#define DIRECTIONS 8 //кол-во направлений: север, юг, запад, восток и т.д.

//Направления, — модель FHP-II.
enum direction
{
    North = 0,
    NE = 1,
    East = 2,
    SE = 3,
    South = 4,
    SW = 5,
    West = 6,
    NW = 7
};

//Структура Клетки
typedef struct cell
{
    unsigned char particles; // Хранит состояние частиц в клетке как битовую маску (8 бит: по одному на направление).
    unsigned char obstacle; // 1 - препятствие; 0 - нет препятствия 
} Cell;


// Функция для выделения памяти под решётку
Cell** lattice(int N)
{
/**
 * @brief Выделяет память под квадратную решётку размером N x N.
 * 
 * Каждая ячейка решётки представляет собой структуру Cell.
 * 
 * @param N Размер стороны решётки.
 * @return Cell** Указатель на двумерный массив Cell.
 * При неудаче выделения памяти программа завершится с ошибкой.
 */
 
    Cell** Lattice = (Cell**)malloc(sizeof(Cell*) * N);
    if (lattice == NULL)
    {
        perror("Не получилось выделить память под решётку :(");
        exit(EXIT_FAILURE);
    }
    for (int i = 0; i < N; i++)
    {
        Lattice[i] = (Cell*)malloc(sizeof(Cell) * N);
        if (Lattice[i] == NULL)
        {
            perror("Не получилось выделить память для строки решётки :(");
            //Освобождение того, что выделили
            for (int j = 0; j < i; j++)
            {
                free(Lattice[j]);
            }
            free(Lattice);
            exit(EXIT_FAILURE);
        }
    }

    return Lattice;
}

//Функция, для освобождения памяти под решётку
void FreeLattice(Cell** Lattice, int N)
{
/**
 * @brief Освобождает память, выделенную под решётку.
 * 
 * @param Lattice Двумерный массив Cell, выделенный функцией lattice.
 * @param N Размер стороны решётки.
 */

    for (int i = 0; i < N; i++)
    {
        free(Lattice[i]);
    }
    free(Lattice);
}

//Функция для инициализации решётки
void initializeLattice(Cell** Lattice, int N, double p, int x, int y, int w, int h)
{
/**
 * @brief Инициализирует решётку частицами и препятствиями.
 * 
 * В ячейках внутри прямоугольника (x, y, w, h) ставится препятствие.
 * Частицы заполняются случайно с вероятностью p для каждого направления.
 * На левой границе решётки создаётся источник частиц, направленных на Восток.
 * 
 * @param Lattice Двумерный массив Cell для инициализации.
 * @param N Размер стороны решётки.
 * @param p Вероятность наличия частицы в каждом направлении.
 * @param x Координата X левого верхнего угла препятствия.
 * @param y Координата Y левого верхнего угла препятствия.
 * @param w Ширина препятствия.
 * @param h Высота препятствия.
 */

    srand(time(NULL));
    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            Lattice[i][j].obstacle = 0;
            Lattice[i][j].particles = 0;
            if (i >= y && i < y + h &&
                j >= x && j < x + w)
            {
                Lattice[i][j].obstacle = 1;
            }
            //Заполнение частиц случайным образом
            for (int d = 0; d < DIRECTIONS; d++)
            {
                if ((double)rand() / RAND_MAX < p)
                {
                    Lattice[i][j].particles |= (1 << d); //Побитовое ИЛИ с присваиванием, а также 1 << d сдвигает биты для d влево, т.е. умножает на 2
                }
            }
            //Источник частиц на левой границе
            if (j == 0)
            {
                Lattice[i][j].particles |= (1 << East); //Генерируем частицу в направлении Востока
            }
        }
    }
}


//Функция для вывода решётки в консоль
void printLattice(Cell** Lattice, int N)
{
/**
 * @brief Выводит текущее состояние решётки в консоль.
 * 
 * Символы:
 * - 'X' — препятствие
 * - '.' — пустая ячейка без частиц
 * - '*' — ячейка с 1-2 частицами
 * - '#' — ячейка с 3 и более частицами
 * 
 * @param Lattice Двумерный массив Cell для вывода.
 * @param N Размер стороны решётки.
 */


    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (Lattice[i][j].obstacle == 1)
            {
                printf("X ");
            }
            else
            {
                int count = 0; //Считаем кол-во частиц
                for (int d = 0; d < DIRECTIONS; d++)
                {
                    if (Lattice[i][j].particles & (1 << d))
                    {
                        count++;
                    }
                }
                if (count == 0)
                {
                    printf(". ");
                }
                else if (count <= 2)
                {
                    printf("* ");
                }
                else if (count >= 3)
                {
                    printf("# ");
                }
            }
        }
        printf("\n");
    }
}



// Функция для распространения частиц
void distribution(Cell** Lattice, Cell** new_Lattice, int N)
{
/**
 * @brief Выполняет распространение частиц по решётке.
 * 
 * Частицы перемещаются в соседние ячейки согласно их направлениям.
 * Обрабатывается периодическое граничное условие (тор).
 * Частицы не перемещаются в ячейки с препятствиями.
 * 
 * @param Lattice Текущая решётка с частицами.
 * @param new_Lattice Решётка, в которую записывается новое состояние.
 * @param N Размер стороны решётки.
 */

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            new_Lattice[i][j].particles = 0; //Обнуляем новое состояние
            //Перемещение частиц из соседних клеток
            new_Lattice[i][j].obstacle = Lattice[i][j].obstacle;
            //North
            if ((Lattice[((i + 1) + N) % N][j].particles & (1 << South)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << N); //ниже функции main() показано, как это работает
            }

            //NE
            if ((Lattice[((i + 1) + N) % N][((j - 1) + N) % N].particles & (1 << SW)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << NE);
            }

            //East
            if ((Lattice[i][((j - 1) + N) % N].particles & (1 << West)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << East);
            }

            //SE
            if ((Lattice[((i - 1) + N) % N][((j - 1) + N) % N].particles & (1 << NW)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << SE);
            }

            //South
            if ((Lattice[((i - 1) + N) % N][j].particles & (1 << North)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << South);
            }

            //SW
            if ((Lattice[((i - 1) + N) % N][((j + 1) + N) % N].particles & (1 << NE)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << SW);
            }

            //West
            if ((Lattice[i][((j + 1) + N) % N].particles & (1 << East)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << West);
            }

            //NW
            if ((Lattice[((i + 1) + N) % N][((j + 1) + N) % N].particles & (1 << SE)) && !Lattice[i][j].obstacle)
            {
                new_Lattice[i][j].particles |= (1 << NW);
            }
        }
    }
}


//Функция для обработки столкновений
void collision(Cell** Lattice, int N)
{
/**
 * @brief Обрабатывает столкновения частиц внутри каждой клетки.
 * 
 * Если клетка — препятствие, частицы отражаются в противоположные направления.
 * Для обычных клеток реализованы упрощённые правила FHP-II:
 * - Столкновение частиц направлений North и South приводит к появлению частиц East и West.
 * - Столкновение частиц North, SE и SW перенаправляет их в South, NE и NW.
 * Если столкновение невозможно, состояние клетки остаётся без изменений.
 * 
 * @param Lattice Двумерный массив Cell, в котором происходит обновление состояний.
 * @param N Размер стороны решётки.
 */


    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            if (Lattice[i][j].obstacle) //Если у нас препятствие
            {
                //Отражение от препятствия
                unsigned char temp = Lattice[i][j].particles;
                Lattice[i][j].particles = 0;
                for (int d = 0; d < DIRECTIONS; d++)
                {
                    if (temp & (1 << d))
                    {
                        //Отражаем направление(идём в противоположное)
                        int opposite_d = (d + 4) % DIRECTIONS;
                        Lattice[i][j].particles |= (1 << opposite_d);
                    }
                }
            }
            else
            {
                // Упрощённые правила FHP-II
                unsigned char temp = Lattice[i][j].particles;
                Lattice[i][j].particles = 0; //Обнуляем, чтобы пересчитать столкновения

                // N и South → перенаправление в East и West. 
                if ((temp & (1 << North)) && (temp & (1 << South)))
                {
                    Lattice[i][j].particles |= (1 << East);
                    Lattice[i][j].particles |= (1 << West);
                }

                //N, SE, SW → перенаправление в South, NE, NW.
                else if ((temp & (1 << N)) && (temp & (1 << SE)) && (temp & (1 << SW)))
                {
                    Lattice[i][j].particles |= (1 << South);
                    Lattice[i][j].particles |= (1 << NE);
                    Lattice[i][j].particles |= (1 << NW);
                }

                //Если столкновение невозможно, состояние остаётся прежним
                else
                {
                    Lattice[i][j].particles = temp;
                }
            }
        }
    }
}


// Функция для сохранения конечного состояния решётки в бинарный файл
void saveLatticeToFile(Cell** Lattice, int N, const char* filename)
{
/**
 * @brief Сохраняет текущее состояние решётки в бинарный файл.
 * 
 * @param Lattice Двумерный массив Cell, который нужно сохранить.
 * @param N Размер стороны решётки.
 * @param filename Имя файла для записи.
 */

    FILE* file = fopen(filename, "wb");
    if (file == NULL)
    {
        perror("Ошибка открытия файла для записи :(");
        return;
    }

    for (int i = 0; i < N; i++)
    {
        fwrite(Lattice[i], sizeof(Cell), N, file);
    }

    fclose(file);
}

// Функция для расчета средней плотности и скорости потока
void calculateStatistics(Cell** Lattice, int N, double* density, double* vx, double* vy)
{
/**
 * @brief Вычисляет среднюю плотность частиц и компоненты средней скорости потока.
 * 
 * Плотность — среднее число частиц на одну ячейку.
 * Скорость рассчитывается как среднее векторное направление всех частиц.
 * 
 * @param Lattice Двумерный массив Cell для анализа.
 * @param N Размер стороны решётки.
 * @param density Указатель на переменную, куда запишется средняя плотность.
 * @param vx Указатель на переменную для средней скорости по оси X.
 * @param vy Указатель на переменную для средней скорости по оси Y.
 */


    *density = 0.0;
    *vx = 0.0;
    *vy = 0.0;

    for (int i = 0; i < N; i++)
    {
        for (int j = 0; j < N; j++)
        {
            int particle_count = 0;
            for (int dir = 0; dir < DIRECTIONS; dir++)
            {
                if (Lattice[i][j].particles & (1 << dir))
                {
                    particle_count++;
                }
            }
            *density += particle_count;

            // Компоненты скорости для каждого направления
            double dir_x = 0.0, dir_y = 0.0;
            switch ((enum direction)0)
            {
            case North: dir_x = 0.0; dir_y = 1.0; break;
            case NE: dir_x = 1.0; dir_y = 1.0; break;
            case East: dir_x = 1.0; dir_y = 0.0; break;
            case SE: dir_x = 1.0; dir_y = -1.0; break;
            case South: dir_x = 0.0; dir_y = -1.0; break;
            case SW: dir_x = -1.0; dir_y = -1.0; break;
            case West: dir_x = -1.0; dir_y = 0.0; break;
            case NW: dir_x = -1.0; dir_y = 1.0; break;
            }
            if (Lattice[i][j].particles & (1 << North)) { dir_x = 0.0; dir_y = 1.0; } //вверх идём
            if (Lattice[i][j].particles & (1 << NE)) { dir_x = 1.0; dir_y = 1.0; } //вверх и вправо
            if (Lattice[i][j].particles & (1 << East)) { dir_x = 1.0; dir_y = 0.0; } //вправо
            if (Lattice[i][j].particles & (1 << SE)) { dir_x = 1.0; dir_y = -1.0; } //вниз и вправо
            if (Lattice[i][j].particles & (1 << South)) { dir_x = 0.0; dir_y = -1.0; } //вниз
            if (Lattice[i][j].particles & (1 << SW)) { dir_x = -1.0; dir_y = -1.0; } //вниз и влево
            if (Lattice[i][j].particles & (1 << West)) { dir_x = -1.0; dir_y = 0.0; } //влево
            if (Lattice[i][j].particles & (1 << NW)) { dir_x = -1.0; dir_y = 1.0; } //влево вверх

            *vx += dir_x;
            *vy += dir_y;
        }
    }

    *density /= (N * N);
    *vx /= (N * N);
    *vy /= (N * N);
}






int main()
{
/**
 • @brief Главная функция программы симуляции клеточного автомата LGA (Lattice Gas Automata).
 • 
 • Выполняет следующие шаги:
 • 1. Считывает с консоли параметры симуляции:
 •    - размер решётки N (максимум MAX_N),
 •    - начальную плотность частиц p,
 •    - количество итераций симуляции,
 •    - параметры прямоугольного препятствия (x, y, w, h).
 • 2. Проверяет корректность введённых данных и при необходимости задаёт значения по умолчанию.
 • 3. Выделяет память под две решётки: текущую и новую.
 • 4. Инициализирует решётку частицами и препятствиями.
 • 5. Выводит начальное состояние решётки в консоль.
 • 6. Выполняет заданное количество итераций симуляции:
 •    - распространение частиц (distribution),
 •    - обработку столкновений (collision),
 •    - обмен указателями решёток.
 • 7. Выводит конечное состояние решётки.
 • 8. Сохраняет конечное состояние в бинарный файл "Lattice.bin".
 • 9. Рассчитывает и выводит среднюю плотность частиц и среднюю скорость потока.
 • 10. Освобождает выделенную память.
 • 
 • @return int Возвращает 0 при успешном завершении программы.
 */

    int n, iterations;
    double p;
    int obstacle_x, obstacle_y, obstacle_w, obstacle_h;


    printf("Введите размер решётки N (<= %d): ", MAX_N);
    scanf_s("%d", &n);
    if (n <= 0 || n > MAX_N)
    {
        printf("Некорректный размер решётки. Используется N=%d\n", MAX_N);
        n = MAX_N;
    }

    printf("Введите начальную плотность частиц p (0.0 - 1.0): ");
    scanf_s("%lf", &p);
    if (p < 0.0 || p > 1.0)
    {
        printf("Некорректная плотность. Используется p=0.3\n");
        p = 0.3;
    }

    printf("Введите число итераций симуляции: ");
    scanf_s("%d", &iterations);
    if (iterations <= 0)
    {
        printf("Некорректное число итераций. Используется iterations=20\n");
        iterations = 20;
    }

    printf("Введите параметры препятствия (x y w h): ");
    scanf_s("%d %d %d %d", &obstacle_x, &obstacle_y, &obstacle_w, &obstacle_h);
    if (obstacle_x < 0 || obstacle_y < 0 || obstacle_x >= n || obstacle_y >= n ||
        obstacle_w <= 0 || obstacle_h <= 0 || obstacle_x + obstacle_w > n || obstacle_y + obstacle_h > n)
    {
        printf("Некорректные параметры препятствия. Используется (1,1,2,2)\n");
        obstacle_x = 1;
        obstacle_y = 1;
        obstacle_w = 2;
        obstacle_h = 2;
    }

    // Выделение памяти под решётку
    Cell** Lattice = lattice(n);
    Cell** new_lattice = lattice(n);

    // Инициализация решётки
    initializeLattice(Lattice, n, p, obstacle_x, obstacle_y, obstacle_w, obstacle_h);

    // Вывод начального состояния решётки
    printf("Начальное состояние:\n");
    printLattice(Lattice, n);

    getchar();
    getchar();
    // Основной цикл симуляции
    for (int iter = 0; iter < iterations; iter++)
    {
        distribution(Lattice, new_lattice, n);
        collision(new_lattice, n);

        // Меняем местами
        Cell** temp = Lattice;
        Lattice = new_lattice;
        new_lattice = temp;
    }
    

// Вывод конечного состояния решётки
    printf("\nПосле %d шагов:\n", iterations);
    printLattice(Lattice, n);

    // Сохранение конечного состояния решётки в файл
    saveLatticeToFile(Lattice, n, "Lattice.bin");

    // Расчет средней плотности и скорости потока
    double density, vx, vy;
    calculateStatistics(Lattice, n, &density, &vx, &vy);

    // Вывод результатов
    printf("\nDensity: %.2f, Velocity: (%.2f, %.2f)\n", density, vx, vy);

    // Освобождение памяти
    FreeLattice(Lattice, n);
    FreeLattice(new_lattice, n);


    getchar();
    getchar();

    return 0;
}


//Сама логика перемещения:
/*
 dir = 0 (N - Север):
    -   (1 << 0)  Сдвигаем бит 1 влево на 0 позиций.
    -   Результат: 00000001  (1 в десятичной системе).  Этот бит соответствует северному направлению.
•   dir = 1 (NE - Северо-восток):
    -   (1 << 1)  Сдвигаем бит 1 влево на 1 позицию.
    -   Результат: 00000010  (2 в десятичной системе).  Этот бит соответствует северо-восточному направлению.
•   dir = 2 (E - Восток):
    -   (1 << 2)  Сдвигаем бит 1 влево на 2 позиции.
    -   Результат: 00000100  (4 в десятичной системе).  Этот бит соответствует восточному направлению.
•   dir = 3 (SE - Юго-восток):
    -   (1 << 3)  Сдвигаем бит 1 влево на 3 позиции.
    -   Результат: 00001000  (8 в десятичной системе).  Этот бит соответствует юго-восточному направлению.
•   dir = 4 (S - Юг):
    -   (1 << 4)  Сдвигаем бит 1 влево на 4 позиции.
    -   Результат: 00010000  (16 в десятичной системе).  Этот бит соответствует южному направлению.
•   dir = 5 (SW - Юго-запад):
    -   (1 << 5)  Сдвигаем бит 1 влево на 5 позиций.
    -   Результат: 00100000  (32 в десятичной системе).  Этот бит соответствует юго-западному направлению.
•   dir = 6 (W - Запад):
    -   (1 << 6)  Сдвигаем бит 1 влево на 6 позиций.
    -   Результат: 01000000  (64 в десятичной системе).  Этот бит соответствует западному направлению.
•   dir = 7 (NW - Северо-запад):
    -   (1 << 7)  Сдвигаем бит 1 влево на 7 позиций.
    -   Результат: 10000000  (128 в десятичной системе).  Этот бит соответствует северо-западному направлению.

Операция grid[i][j].particles |= (1 << dir):

Эта операция устанавливает бит, соответствующий направлению dir, в переменной grid[i][j].particles.  Оператор |= (побитовое ИЛИ с присваиванием) выполняет побитовое ИЛИ между текущим значением grid[i][j].particles и битовой маской (1 << dir), а затем присваивает результат обратно grid[i][j].particles.
*/

/*
Пример тестов:
1)
Введите размер решётки N (<= 64): 10 
Введите начальную плотность частиц p (0.0 - 1.0): 0.3
Введите число итераций симуляции: 5
Введите параметры препятствия (x y w h): 2 2 4 4
Начальное состояние:
# * # * * # * # # #
# * * * # # * * # *
# # X X X X * # # *
# # X X X X . # # #
# # X X X X # * # #
# . X X X X # * * *
* # * . # . * . * #
# # # * * # * * # *
* . . # # * * * * *
* # * * * * * * * #


После 5 шагов:
# * * * * . * * * #
* * * * * * * * * #
# * X X X X * * # #
. . X X X X * * # #
# * X X X X * * * *
# . X X X X * * * *
* * * * . # . * * #
* * # . * * # # . *
. * * * . * . * . *
* * . . * * * . # *

Density: 1.36, Velocity: (-0.37, 0.34)

2)
Введите размер решётки N (<= 64): 20
Введите начальную плотность частиц p (0.0 - 1.0): 0.5
Введите число итераций симуляции: 10
Введите параметры препятствия (x y w h): 2 2 5 5
Начальное состояние:
# # # # # # # # # # # # # # # * # # # #
# # # # # * # # # * # # * # # # # * # #
# # X X X X X # # # # # # # # * # # # #
# # X X X X X # # # # # # # # # # # # #
# # X X X X X # # # # # # # * # # # # #
# # X X X X X # # # # * # # # # # # # #
# # X X X X X # * * # * # # # * # # # .
# # # # # # # # # # # # # # # # # # # #
* # # * # # # # # # # * # * # * # # # #
# # # # # # # # # # # # # # # * # # # #
# # * # # # # # # # # # # # # # # # # #
# # # * # # * # * # # # # # * # . # * #
# # # # # # # * # . # # # # # # # # # *
# # # * # # # # # # * # # # # * # # # .
# # # # # * * # # # # # # # # * # # # #
# # # * # # # # * # # # # * # * # # * #
# # # * # # # # # # # # # # # # # * # *
# # # * # # # # # # # # # # # * * # # #
# * # # # # # # # # # # # # # # # # # #
# # # # # # * # # # # # # # # # # # # #


После 10 шагов:
# # * # # * # # # * # # # # # * # # # #
# # # # * . # # * . # # * * # # * * # #
# * X X X X X * # # # # # # * * # # # #
# * X X X X X * * # # # # # # # # * * #
# * X X X X X * # * # * # * * # # # # #
# * X X X X X * # # # * # # * # # # * #
* * X X X X X # * * # * # * # * # # # .
# # # # # # # * * # # # # # * # # # # *
* # # * * # # # # # # * # * # * * * # #
# # # # # # # # # * # # * * # * * # # *
# # * * * # # # # # # * # * * # # # * #
# # # * # # * # * * * # # * * # . * * #
* # # # # * # * # . # # # # # # # # # *
# # # * # # # # # * * # # * # * # # * .
# # # # # * * # # * # # # # # * # # * #
# # * * # # * # * # # * # * # * # # * #
# # * * # # # # # * # # * # # # # * * *
# # # * # * * # # # # * * # # * * # # *
# * # # # # # # # * # # # # * # # * # *
# # # # # # * * # # # * * * * # # # # #

Density: 2.82, Velocity: (-0.71, 0.36)



3)

Введите размер решётки N (<= 64): 50
Введите начальную плотность частиц p (0.0 - 1.0): 0.5
Введите число итераций симуляции: 5
Введите параметры препятствия (x y w h): 10 10 10 10
Начальное состояние:
# # # # # # * # # # # # # # . # # # # # # # # # # # # # # * # # # # * # # # * # # # # # # # * * * *
# * # # # * # * # # # # # # * * # # # # # # # # # * # # # # # # # # * # # * # # # # # # # * # # * #
# # # # # # # # # * # # # # # # # # # # # * * # # # # # # # # # # # # # # * # # # # * # # * # # # #
* # # # # # # # # * * # # # # # # # # # * * # # # # # # # * # * # # # # # # * # # # # # * * * # # #
# # # # # # # # * # # # # # # * * * * # # # # # # # # # # # # # # # # * # # # # # * # # # * * # # #
# # # * # # # # # * # # # # * # # # # # # # # # # # # * # # # # # # * # # # # # # # * # # * # # # #
# # # * # * # # # # * # # # * * # * * # # # # # # # # # # # # * # # # # # # # # # # # # # # # # # #
# # # # # # # # # # # # # # # # # # # * # # # * # # * # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # * # # # # # # # # # * * * # # * # # # # # # # # # # # # # * # * # # # # # # # # # # #
# # * * # # # # # # # # # # # * # # # # # # # * # # # # # # # # # * # # # # * . # # # # # # * # # #
# # # # # # # # * # X X X X X X X X X X # # # # # # . # # * * # # # # # # # # # # # * # # # # * # #
# # * # # * # # # # X X X X X X X X X X * # # # # # # # # # # # # # # * * * # # # # # # # # # # * #
* # # # # * # # * # X X X X X X X X X X # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
# # * # # # # * # * X X X X X X X X X X # # # # # # # # # # # # # # # # # * # # # # # # # * # # # #
# # # # # * # # # # X X X X X X X X X X # # # # # # # # # # # # # # * # # # # # # # * # # # # # # #
# # # # * # # # # # X X X X X X X X X X # * . # * # # # # * # # # # # # * # # # # # # # # # # # # #
# # # # # # # # # # X X X X X X X X X X # # # # # # # # # # # # # # # # # # # # # * # # # # # * # #
# # # # # # # # # . X X X X X X X X X X # # # # # # # # # # # # # # * # * # # # # # # # # # * # # *
# # # # # # # # # * X X X X X X X X X X # # # # # # # * # # # # # # # # # # * # # # # # # # # # # #
# # # # # # * # # * X X X X X X X X X X * # # # # # # # # # # # # # # * # # * # # # * # # # # # # #
# # # # # # # # * # # # # # # # # # # * * # # # # * # # # # * # # # # # # * # # # # # # # # # # # #
# # # # * # * * # * # * # # * * # # # * * # # # # # # # # # # # # * # # # # # * # * # # # # # # # #
# * # # # # # # * # # * * # # # * # # # # * # # # * # * # # # * # # # # # # # # # # * # # # * # # #
# # # # # # # # # # # # # # # # # # # # # # # # # * # # # # # # * # # # # * # # # # # # # # # # # #
# # # # * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # * # # # # # * # # #
# # * # * # # # # # # # # # # # # # # # # # # * # # # * # * # # # # * # # # # * # # # # # # # # # #
# * * # # # # # # # * # * # # # # # # # # # # * * # # # * # # # # # # # # # # * * # # * # # # * # #
# # # # # # * # # # # * # * # # # # # # # # # # # # # # # # # # # # # * # # # # # * # * # # # * # #
# # # # # # * # # # # * # # # # # * # # * * # # # * # # # # # # * # # # # # # # # # # # # * * # # #
# # # # * # # # # # # # # * # * # # # # # # # * # # # # # # # # # # * # # # * # # # # # # # # # # #
# # # # # # # * # * # # # # * # # # # # # # # # # * # * # # # # # # # # # # # # # # * # # # # # # #
# # # * # # * # # # # # # # # * # # # # # # # # # # # # # * # # * # * # # # # # # # . # # # # # # #
# # # # # # # # # # # * # # # # # # # # . * # # # # # * # # # # # # # # # # # # # # # # # # # # # #
# # * * # # # # # # # # * # # # # * * # # # # # # # # # # # # # # # * # # # # # # # # # # # # * # #
* # # # * # * # # # # # # # * # # # # # # # # * # # # # # # # # # # # # # # # # # # # # # # # # # #
# # # * # # # # # # # # # # # # # # # # # # # * # # # # # # # # # # # * # * * # # # # # # # # # # #
* # * # # # # # * * # * # * # # # # * # # # # # * # # # # # # # # * # * # # * # # # # # # # # # # #
# # # # # # # # # # # # * # # # * # # # # # * # # * # # # # * * # # # # # # # # # # # * # # * # # *
# # # # # * # # # # * # # # * . # # # # # * # # # # * # # # # # # # # * # # # # * # # * # # # * * #
# # # # # # # # # # # # # # # # # # * # # # * * # # * # # # # * # # # * # # # * # # # # # # # * # #
# * # # # # # * # # # # # # * # # # # # # # # * # * * # # # # # # # # # # # # # # # # # # # # * # #
# # # # # # # # # # # # # # # # # * * # # * # # # # # # # # * # # # # # * # # # # * # # # * # # # #
# * # # # # # * # # # # * # # # # # # # * # # # # * # * # # # # # # # # # # # # # * # # # # * # # #
# # # # * # # # # # # # * # # # # # # * # * # # # # # # * # # # # # # # # # # # # # # # # # # # * #
# # # # # # # # * # # # # # # # # # # # * # # # # # # # # # * # # # # # # # * # # # * # # # # # # #
# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # * # # # # # # * * # # # # # # # # # # #
# # # # # # # * # # # # * # # * # # # # # # # # * # # # # # # # # # # # # # # # # # # # # # # # * #
# # # # * # # # # # # # # # # * # * # # # # # # . # # # # # # # # # # # # # # # # # # # # # # # # #
# # # # # # # * # # # # * # * # * # * # # # # # # # # # * # # # # * * # # # # # # * # * # # # # # #
# # # # # # # * # # # . # # * # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # * #


После 5 шагов:
# # # # * # * # * # # # # . # # * # # # # * # # # * # # * # # # * * * # * * # # * # * * # * # * * *
# * * # # # # # # # * * * * * * # # # # # # # # * # * # # # # # # # # * * # * # # * * * # # # * * #
# * # # # # # # * * * * * * # # # # # # # # * # # * * # # # # * * # # # * # * # # # # * * * * # * *
* # # * * # # # # # * * # # # * * * # # * # # # # * # # # # * * # # * # * . * # * # # # * * * * # #
# * # # # * * # # * # * # # * * # # * # * # * # # # # * # # # * # * * # # * # # # # # # # # * # * #
# # # * . # # # * * * # # # * * . # . * * # # # * # # # * # # # # # * * * # # # # # # # # * # * # *
# * * # # # # # * # * * * * # # . * # # # # # * # # # # * # # # # * # * # * # # # # # # * # # # # #
# # # * * # * # # * # * # * * * # # * # # # # # * # # * # # # # # * * # * # # * # # # * * * # * * *
# # # # # # # # # * # # # * # # # # # * # * # * # # . # * # * # * # # * * # . * # # # * * # # * # #
# # # # # # # # * # # * # * * # * * * . * # # # * # # # # # # # # # * # # # * * * * # # # * # * # #
# # * # * # # * * # X X X X X X X X X X # * # # * # # # * # # # # # * * # * * # # * # # # # # # # *
* # # # * * * . # * X X X X X X X X X X # . # # # * # # # # * # # . # * * # * # # # # # # * # * # *
# # * * # # * # * * X X X X X X X X X X * # # # # # * # # * * # # # # # . * * # # # # # # # * * # *
# # * # # # * # # . X X X X X X X X X X * # # * # # # # # # # # * # # * # # * # # # # . * * # # # *
# # * # # # # # * * X X X X X X X X X X * * * * # # # * . # # * # # # # # * # * # # # * * # . # # #
# * # # * # * # # * X X X X X X X X X X * # # * # * # # # * * * # # # * * . * * * # # * * # # # * #
# * # # * # # # # . X X X X X X X X X X * * # # # # # # # # # # # # # * # # # # # # # # * # # * # #
# # # * # * # * * * X X X X X X X X X X * # * * * # * # # # * # # # # * # # * * * # # # # # # # # #
# * # * * # * # * * X X X X X X X X X X # # # # * # # # # # * # # # # * * * * * # * # * # # # # # *
# # # # # # # * # # X X X X X X X X X X * # # * * * * # # # # # # * # * * # # * # # # * # # * # # #
# * # # # # # * * # # # * * * * * * . * * * # # * * # * # # # * # # * * # # # # * # # # # # # * # #
* # * * # # # * # # * * * # # * # # * * # * * * * # # * # # . * # # # # # * * * * # # # # # * # . #
# * * # # # # # * # # * * # # # * # * * * # * # # # * # # # * # # # * # # # * # * # # * # * # # # #
# # # # # * # # # # # * # * # # * * # # # # # # * # * # # # # # # * * # # * * # # * # # # # # * * #
* # # # # # # * # * * # * # # * * # # # # * # * * # # # * # * * * # # * # # * # # # # * # # # * * *
* # # # # * # # # * # # * # * # # # # * * # # * # * # * # # # * # * # # . * * # * * # # # # # # # #
* # # * * # # # * * * * # # * * * # # # # # * # # # # # # # # * # * # * * # * # # # * # # # * * * #
* # . * * . * * # * * # # # * # # # * # # * * # # # * # * # * # # # # # # # # # # # * # * * # # # #
# * # # # * * # # * # # * # * * # # * * # # # # * * # # # * # * # # # # # * # * * # # * * * # # # *
* # # * # * # # # # * # # # # # # # # # . * # * # * # # # # # # * * # # * # # # * . # # * # # * * #
# * # # # # # * * * # # * # # # # * * # # * # * * # # # * # * * . * # * # * * # # * * # # * # * # *
# # # # # # # # * # # # # * # * # * # # * # # # * # * # * # # # # # # # # # # # * * # . # # # # # #
# # * * * * * # # # # * # # * # * # # * # * * # # # # # * # # # # # * # * # * # # # # # * * # * # #
* # * # * # # . # * * # # # # # * # # * # # # * * # * # * # # * # # # # * * # # # * # # # # # # # #
# # * * * # # # # # * # * # * # # * # * # # # # * # # # # # * # # * # * # * * # * # # # * # # # # #
* * * # * * # # * * # # # * # # # # # # * # * # * * # # # # # # * # # # * # * # * * * # # # # * # #
# * * # # # # # # # * * * # # * * # # # * * # # # # * # # # # # * # # # * * # * # # * # * * * * * #
* * # # # # # * * # # * * * * # # # # * # # # # # * * # # # * # # # * # * * * * # * # * # # # # * #
# * # # * # # # * * * # # # * * # * # # # * # * # # # * * # * # * # * # # # # # # * . # * # * # * #
# # * * # # # # # # # * # * * # * # # * # * * # * * # * # # # * # # * # # # * * # # # * . * # # # #
* # # # * * * # # # # * * * # # * * * # # * * # * # # # # # * # # # * # # * # # # # # # # # # # * #
* # * # * # . * # # # # # # # # * * # # * # # # # . * # # # # * # # # * # * # # . # # # # # # * # *
# # # * # # * # # # # * # * # # # # # * * # # # * * # . * * # * * # # * * # * # # # * * # * # # # #
# # # # # * * * * # # * * # # # # # * # # # # * # # # # # # # * * # # * # # # # # # # # # # * * * #
* # # # # * * * # # * * * # # # # # # # # * * * # # # # * * # # * # # # * * # # # # # # # * # * # #
# # * * # # * # # * # # # * # * # # # # # # # # * * # # * * # # # * # # # * # * # * # # # # # * * #
# * # # # # # # * # # # # * # # * * # # # # # # # # # # # # # # * * # # # * * # # * # # * * # # * *
* # # # # * # # * # # * # # * * # # # # # # . * # # * # # # # # * # # # * # * # # # * # * # # # # #
# * * # # * # # # # # * * # # * # # # # # # # # * * # # # * # # # * # # # # * # # # # * * # # * # #
# # * # * # * # * # # # * * # * # # # * # # # # # * * # # # # # # * # # # # # # * # * * # # # * # #

Density: 2.88, Velocity: (-0.74, 0.37)

*/